&ACCESS R
DEF mappings()
    ; =============================================
    ; Copyright 2025 KUKA Hungaria Kft.
    ;
    ; Licensed under the Apache License, Version 2.0 (the "License");
    ; you may not use this file except in compliance with the License.
    ; You may obtain a copy of the License at
    ;
    ;     http://www.apache.org/licenses/LICENSE-2.0
    ;
    ; Unless required by applicable law or agreed to in writing, software
    ; distributed under the License is distributed on an "AS IS" BASIS,
    ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ; See the License for the specific language governing permissions and
    ; limitations under the License.
    ; =============================================
END

; Converts a boolean to an integer
GLOBAL DEFFCT INT ROS_BoolToInt(boolean: IN)
    BOOL boolean

    IF boolean THEN
        RETURN 1
    ENDIF

    RETURN 0
ENDFCT

; Returns the current operation mode as an integer
GLOBAL DEFFCT INT ROS_OperationModeToInt()
    IF $T1 THEN
        RETURN 1
    ENDIF

    IF $T2 THEN
        RETURN 2
    ENDIF

    IF $AUT THEN
        RETURN 3
    ENDIF

    ; $EXT
    RETURN 4
ENDFCT

; Return the axis type string associated with the given integer
GLOBAL DEFFCT CHAR [32] ROS_AxisTypeIntToString(axis_type_int: IN)
    INT axis_type_int
    INT idx

    FOR idx = 1 TO AXIS_TYPE_COUNT
        IF AXIS_TYPE_TUPLES[idx].axis_type_int == axis_type_int THEN
            RETURN AXIS_TYPE_TUPLES[idx].axis_type_string[]
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "INVALID"
ENDFCT

; Returns the command type associated with the given integer
GLOBAL DEFFCT CommandType ROS_IntToCommandType(command_type_int: IN)
    INT command_type_int
    INT idx

    FOR idx = 1 TO COMMAND_COUNT
        IF command_type_int == idx - 1 THEN
            RETURN COMMAND_TYPES[idx]
        ENDIF
    ENDFOR

    RETURN #CMD_INVALID
ENDFCT

; Returns the control mode associated with the given integer
GLOBAL DEFFCT ControlMode ROS_IntToControlMode(control_mode_int: IN)
    INT control_mode_int
    INT idx

    FOR idx = 1 TO CONTROL_MODE_COUNT
        IF CONTROL_MODE_TUPLES[idx].control_mode_int == control_mode_int THEN
            RETURN CONTROL_MODE_TUPLES[idx].control_mode
        ENDIF
    ENDFOR

    RETURN #INACTIVE
ENDFCT

; Returns the string representation of the specified control mode
GLOBAL DEFFCT CHAR [32] ROS_ControlModeToString(control_mode: IN)
    DECL ControlMode control_mode
    INT idx

    FOR idx = 1 TO CONTROL_MODE_COUNT
        IF CONTROL_MODE_TUPLES[idx].control_mode == control_mode THEN
            RETURN CONTROL_MODE_TUPLES[idx].control_mode_string[]
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "NOT_FOUND"
ENDFCT

; Returns the integer representation of the specified control mode
GLOBAL DEFFCT INT ROS_ControlModeToInt(control_mode: IN)
    DECL ControlMode control_mode
    INT idx

    FOR idx = 1 TO CONTROL_MODE_COUNT
        IF CONTROL_MODE_TUPLES[idx].control_mode == control_mode THEN
            RETURN CONTROL_MODE_TUPLES[idx].control_mode_int
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN -1
ENDFCT

; Return the cycle time associated with the given integer
GLOBAL DEFFCT ROS_CycleTime ROS_IntToCycleTime(cycle_time_int: IN)
    INT cycle_time_int
    INT idx

    FOR idx = 1 TO CYCLE_TIME_COUNT
        IF CYCLE_TIME_TUPLES[idx].cycle_time_int == cycle_time_int THEN
            RETURN CYCLE_TIME_TUPLES[idx].cycle_time
        ENDIF
    ENDFOR

    RETURN #NONE_CYCLE_TIME
ENDFCT

; Returns the string representation of the specified cycle time
GLOBAL DEFFCT CHAR [32] ROS_CycleTimeToString(cycle_time: IN)
    DECL ROS_CycleTime cycle_time
    INT idx

    FOR idx = 1 TO CYCLE_TIME_COUNT
        IF CYCLE_TIME_TUPLES[idx].cycle_time == cycle_time THEN
            RETURN CYCLE_TIME_TUPLES[idx].cycle_time_string[]
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "NOT_FOUND"
ENDFCT

; Returns the integer representation of the specified cycle time
GLOBAL DEFFCT INT ROS_CycleTimeToInt(cycle_time: IN)
    DECL ROS_CycleTime cycle_time
    INT idx

    FOR idx = 1 TO CYCLE_TIME_COUNT
        IF CYCLE_TIME_TUPLES[idx].cycle_time == cycle_time THEN
            RETURN CYCLE_TIME_TUPLES[idx].cycle_time_int
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN -1
ENDFCT

; Returns the string represenation of the specified driver state
GLOBAL DEFFCT CHAR [32] ROS_DriverStateToString(driver_state: IN)
    DECL DriverState driver_state
    INT idx

    FOR idx = 1 TO STATE_COUNT
        IF DRIVER_STATE_TUPLES[idx].driver_state == driver_state THEN
            RETURN DRIVER_STATE_TUPLES[idx].driver_state_string[]
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "INVALID"
ENDFCT

; Returns the integer representation of the specified event type
GLOBAL DEFFCT INT ROS_EventTypeToInt(event_type: IN)
    DECL EventType event_type
    INT idx

    FOR idx = 1 TO EVENT_COUNT
        IF event_type == EVENT_TYPES[idx] THEN
            RETURN idx - 1
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN -1
ENDFCT

; Maps the specifed control mode and cycle time to a program name if available
GLOBAL DEFFCT CHAR [64] ROS_GetProgramName(control_mode: IN, cycle_time: IN)
    DECL ControlMode control_mode
    DECL ROS_CycleTime cycle_time
    INT idx
    BOOL control_mode_ok
    BOOL cycle_time_ok

    FOR idx = 1 TO PROGRAM_CONFIG_COUNT
        control_mode_ok = PROGRAM_CONFIGS[idx].control_mode == control_mode
        cycle_time_ok = PROGRAM_CONFIGS[idx].cycle_time == cycle_time
        IF control_mode_ok AND cycle_time_ok THEN
            RETURN PROGRAM_CONFIGS[idx].program[]
        ENDIF
    ENDFOR

    RETURN "INVALID"
ENDFCT
