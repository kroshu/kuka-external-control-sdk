&ACCESS R
DEF eki_communication()
    ; =============================================
    ; Copyright 2025 KUKA Hungaria Kft.
    ;
    ; Licensed under the Apache License, Version 2.0 (the "License");
    ; you may not use this file except in compliance with the License.
    ; You may obtain a copy of the License at
    ;
    ;     http://www.apache.org/licenses/LICENSE-2.0
    ;
    ; Unless required by applicable law or agreed to in writing, software
    ; distributed under the License is distributed on an "AS IS" BASIS,
    ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ; See the License for the specific language governing permissions and
    ; limitations under the License.
    ; =============================================
END

GLOBAL DEF EKI_ServerStart()
    DECL INT ret

    ResetComponents()

    ; Init connection flag - will be set TRUE internally by EKI after connection is made
    $FLAG[ROS_EKI_CONN_FLAG] = FALSE
    ; Init data recv flag - will be set TRUE internally by EKI after data is received
    $FLAG[ROS_EKI_RECV_FLAG] = FALSE
    Connected = FALSE

    ret = EKI_Load(INTERFACE_NAME[])
    ret = EKI_Open(INTERFACE_NAME[])
END

GLOBAL DEF EKI_ServerReset()
    DECL INT ret
    ret = EKI_Clear(INTERFACE_NAME[])
    EKI_ServerStart()
END

DEF ResetComponents()
    ROS_ResetCommandHandler()
    ROS_ResetProgramHandler()
    ROS_ResetStatus()
END

; Tries to read received elements from buffer.
GLOBAL DEF EKI_ReceiveData(command: OUT)
    DECL Command command
    DECL INT ret

    ; Init cmd
    command.cmd_int = 5 ; By default use the none command
    command.control_mode = -1
    command.cycle_time = -1

    ; Verify a valid connection
    IF NOT IsClientConnected() THEN
        WAIT SEC 0.012
        RETURN
    ENDIF

    ; Skip processing if no data received.
    IF NOT DidReceiveData() THEN
        WAIT SEC 0.012
        RETURN
    ENDIF

    ; Reset flag immediately after msg notification
    $FLAG[ROS_EKI_RECV_FLAG] = FALSE

    ret = EKI_ReadNext(INTERFACE_NAME[])

    IF ret == EkiOk THEN
        ret = EKI_GetInt(INTERFACE_NAME[], "REQTYPE", command.cmd_int)
        ret = EKI_GetInt(INTERFACE_NAME[], "ControlMode", command.control_mode)
        ; Cycle time is not removed from telegram, but has only 1 supported value
        ret = EKI_GetInt(INTERFACE_NAME[], "CycleTime", command.cycle_time)
    ELSE
        ROS_Error("No valid data received")
        WAIT SEC 0.012
    ENDIF
END

GLOBAL DEF ROS_HandleConnection()
    DECL INT ret
    IF IsClientConnected() THEN
       ret = EKI_GetBufferedMsgCount(INTERFACE_NAME[])
       if ret < 0 THEN
           ROS_Info("Communication channel is down")
           Connected = FALSE
       ENDIF
    ENDIF       
    IF IsClientConnected() <> connection_flag THEN
        connection_flag = IsClientConnected()
        IF IsClientConnected() THEN
            ROS_Info("External client connected")
        ELSE
            ROS_Info("External client disconnected")
            EKI_ServerReset()
        ENDIF
    ENDIF
    
END

GLOBAL DEF ROS_PublishEvent()
    DECL INT ret
    INT event_int
    CHAR resp_value[]
    
    IF last_event <> #NONE THEN
        IF NOT IsClientConnected() THEN
            ;ROS_Error("External client is not connected when trying to send event")
            RETURN
        ENDIF

        event_int = ROS_EventTypeToInt(last_event)
        ret = EKI_SetInt(INTERFACE_NAME[], "EventID", event_int)

        ; Only list commands that need special handling
        SWITCH last_event
            CASE #CONNECTED
                ROS_WriteInitData()
                ; Send empty response
                ret = EKI_SetString(INTERFACE_NAME[], "Response", " ")
            CASE #SWITCH_OK
                ; TODO: EKI_SetString returns error when using ROS_GetSelCtrlModeStr
                ; As only 1 control mode is supported, return it hard-coded for now
                ret = EKI_SetString(INTERFACE_NAME[], "Response", "Joint Position Control")
            CASE #STATUS_UPDATED
        ENDSWITCH

        ; Send the message
        ret = EKI_Send(INTERFACE_NAME[])
        
        IF ret == EkiInvalidOperation THEN
           ROS_Error("EkiInvalidOperation for send")
           Connected = FALSE
        ENDIF
   
        ; Reset event
        ROS_SetLastEvent(#NONE)
        ret = EKI_SetString(INTERFACE_NAME[], "Response", " ")
    ENDIF
END

GLOBAL DEF ROS_SetLastEvent(event: IN)
    DECL EventType event
    last_event = event
END

GLOBAL DEFFCT BOOL IsClientConnected()
    RETURN Connected OR $FLAG[ROS_EKI_RECV_FLAG] ; Connected flag removed from EKI6.1
ENDFCT

DEFFCT BOOL DidReceiveData()
    RETURN $FLAG[ROS_EKI_RECV_FLAG]
ENDFCT

GLOBAL DEF ROS_WriteInitData()
    DECL INT eki_ret

    ROS_WriteStatus()

    ; Set general parameters
    eki_ret = EKI_SetString(INTERFACE_NAME[], "VER", INTERFACE_VERSION[])
    eki_ret = EKI_SetInt(INTERFACE_NAME[], "NumAxes", $NUM_AX)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], "NumExternalAxes", $EX_AX_NUM)
    eki_ret = EKI_SetString(INTERFACE_NAME[], "Model", $ROBTRAFO[])
    eki_ret = EKI_SetString(INTERFACE_NAME[], "RobVer", $V_R1MADA[])
END
