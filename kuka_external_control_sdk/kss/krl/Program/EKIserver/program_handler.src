&ACCESS RV3
&PARAM DISKPATH = KRC:\R1\Program\ROS
DEF program_handler()
    ; Software License Agreement (BSD License)
    ;
    ; Copyright (c) 2022, Kuka Robotics Corp
    ; All rights reserved.
    ;
    ; Redistribution and use in source and binary forms, with or without
    ; modification, are permitted provided that the following conditions are met:
    ;
    ;      * Redistributions of source code must retain the above copyright
    ;        notice, this list of conditions and the following disclaimer.
    ;      * Redistributions in binary form must reproduce the above copyright
    ;        notice, this list of conditions and the following disclaimer in the
    ;        documentation and/or other materials provided with the distribution.
    ;      * Neither the name of the copyright holder, nor the names of its
    ;        contributors may be used to endorse or promote products derived
    ;        from this software without specific prior written permission.
    ;
    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    ; POSSIBILITY OF SUCH DAMAGE.
END

GLOBAL DEFFCT BOOL ROS_StartProgram()
    CHAR program_name[64]
    CHAR s[256]
    INT k

    ROS_GetProgramName(selected_control_mode, selected_cycle_time, program_name[])

    ; Check to see if a program is already selected - should not happen
    IF ($PRO_STATE1 <> #P_FREE) THEN
        ; If a program is already selected, log error and return
        MsgNotify("Program %1 is already selected", "PC", , $PRO_NAME1[], 1)
        RETURN FALSE
    ENDIF

    ; Select the new program
    s[] = "RUN/"
    k = strAdd(s[], program_name[])

    CWRITE($CMD, statement_state, command_mode, s[])
    IF (NOT WaitForStateTransition(#P_FREE, 1000)) THEN
        MsgNotify("Timeout selecting program %1", "PC", , program_name[], 5)
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

GLOBAL DEFFCT BOOL CancelProgram()
    ;FOLD Help
        ; Cancels the robot program.  If no program is selected, this does not return an error.
        ; @Return
        ;    TRUE - Successfully cancelled program (or no program was selected)
        ;    FALSE - Timeout occured while trying to cancel program
        ;
    ;ENDFOLD

    MsgNotify("Cancelling program...", "ProgramHandler")

    ; Check to see if no program is selected
    IF ($PRO_STATE1 == #P_FREE) THEN
        RETURN TRUE
    ENDIF

    IF ($PRO_STATE1 == #P_ACTIVE) THEN
        MsgNotify("Sending stop command", "ProgramHandler")
        CWRITE($CMD, statement_state, command_mode, "STOP 1")
        IF (WaitForStateTransition(#P_ACTIVE, 1000) <> TRUE) THEN
            MsgNotify("Timeout stopping program", "PC", 0, " ", 3)
            RETURN FALSE
        ENDIF
    ENDIF

    ; Cancel the program
    MsgNotify("Sending cancel command", "ProgramHandler")
    CWRITE($CMD, statement_state, command_mode, "CANCEL 1")
    IF (NOT WaitForState(#P_FREE, 1000)) THEN
        MsgNotify("Timeout cancelling program", "PC", 0, " ", 4)
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

GLOBAL DEFFCT BOOL ResetProgram()
    ;FOLD Help
        ; Resets the robot program.  If the program is already reset, this does not return an error.
        ;
        ;
        ; @Return
        ;    TRUE - Successfully reset program
        ;    FALSE - Timeout occured while trying to reset program
    ;ENDFOLD

    ; If program is already reset, just return
    IF ($PRO_STATE1 == #P_RESET) THEN
        RETURN TRUE
    ENDIF

    ; Check for no program selected
    IF ($PRO_STATE1 == #P_FREE) THEN
        MsgNotify("No program selected", "PC", 0, " ", 7)
        RETURN FALSE
    ENDIF

    ; If the program is running, stop it
    IF ($PRO_STATE1 == #P_ACTIVE) THEN
        CWRITE($CMD,statement_state,command_mode,"STOP 1")
        IF (WaitForStateTransition(#P_ACTIVE, 1000) <> TRUE) THEN
            MsgNotify("Timeout stopping program", "PC", 0, " ", 3)
            RETURN FALSE
        ENDIF
    ENDIF

    ; Reset the program
    CWRITE($CMD,statement_state,command_mode,"RESET 1")
    IF (NOT WaitForState(#P_RESET, 1000)) THEN
        MsgNotify("Timeout resetting program", "PC", 0, " ", 8)
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

GLOBAL DEFFCT BOOL StopProgram()
    ;FOLD Help
        ; Stops the robot program.  If the program is not running or no program is selected, this does not return an error.
        ;
        ; @Return
        ;    TRUE - Successfully stopped program
        ;    FALSE - Timeout occured while trying to stop program
    ;ENDFOLD
    IF ($PRO_STATE1 == #P_ACTIVE) THEN
        CWRITE($CMD,statement_state,command_mode,"STOP 1")
        IF (WaitForStateTransition(#P_ACTIVE, 1000) <> TRUE) THEN
            MsgNotify("Timeout stopping program", "PC", 0, " ", 3)
            RETURN FALSE
        ENDIF
    ENDIF
    RETURN TRUE
ENDFCT

DEFFCT BOOL WaitForState(ProState: IN, Timeout: IN)
    ;FOLD Help
        ;   Used internally to wait for a specific program
        ;   state or timeout, whichever comes first.
        ; @Inputs
        ;   @param ProState
        ;      ENUM PRO_STATE: #P_ACTIVE,#P_FREE,#P_END,#P_RESET,#P_STOP
        ;
        ;   @param Timeout
        ;      Maximum time to wait in milliseconds.
        ;
        ; @Outputs
        ;   None
        ;
        ; @Return
        ;    TRUE - Program state condition was met
        ;    FALSE - Timeout occured
        ;
    ;ENDFOLD
    DECL PRO_STATE ProState
    INT Timeout
    INT StartTime, TriggerTime

    StartTime = $ROB_TIMER

    ; Set the trigger time based on the start time.  Account for integer rollover
    IF ((INTEGER_MAX-Timeout) < StartTime) THEN
        TriggerTime = Timeout - (INTEGER_MAX-StartTime)
    ELSE
        TriggerTime = StartTime + Timeout
    ENDIF

    IF (TriggerTime >= StartTime) THEN
        ; No worries about timer rollover
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 == ProState) OR ($ROB_TIMER > TriggerTime) OR ($ROB_TIMER < StartTime))

    ELSE
        ; Timer rollover must be accounted for
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 == ProState) OR (($ROB_TIMER > TriggerTime) AND ($ROB_TIMER < StartTime)))
    ENDIF

    IF ($PRO_STATE1 == ProState) THEN
        RETURN TRUE
    ENDIF

    RETURN FALSE
ENDFCT

DEFFCT BOOL WaitForStateTransition(ProState: IN, Timeout: IN)
    ;FOLD Help
        ;   Used internally to wait for a program state transition FROM the given state
        ; @Inputs
        ;   @param ProState
        ;      ENUM PRO_STATE: #P_ACTIVE,#P_FREE,#P_END,#P_RESET,#P_STOP
        ;
        ;   @param Timeout
        ;      Maximum time to wait in milliseconds.
        ;
        ; @Outputs
        ;   None
        ;
        ; @Return
        ;    TRUE - Program state condition was met
        ;    FALSE - Timeout occured
        ;
        ;
    ;ENDFOLD
    DECL PRO_STATE ProState
    INT Timeout
    INT StartTime, TriggerTime

    StartTime = $ROB_TIMER

    ; Set the trigger time based on the start time.  Account for integer rollover
    IF ((INTEGER_MAX-Timeout) < StartTime) THEN
        TriggerTime = Timeout - (INTEGER_MAX-StartTime)
    ELSE
        TriggerTime = StartTime + Timeout
    ENDIF

    IF (TriggerTime >= StartTime) THEN
        ; No worries about timer rollover
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 <> ProState) OR ($ROB_TIMER > TriggerTime) OR ($ROB_TIMER < StartTime))
    ELSE
        ; Timer rollover must be accounted for
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 <> ProState) OR (($ROB_TIMER > TriggerTime) AND ($ROB_TIMER < StartTime)))
    ENDIF

    IF ($PRO_STATE1 <> ProState) THEN
        RETURN TRUE
    ENDIF

    RETURN FALSE
ENDFCT

GLOBAL DEF ROS_SelectControlMode(mode: IN)
    DECL ControlMode mode
    CHAR mode_string[32]

    mode_string[] = ROS_ControlModeToString(mode)
    MsgNotify("Control mode set to %1", "ProgramHandler",, mode_string[])

    selected_control_mode = mode
END

; Returns the selected control mode as a string
GLOBAL DEFFCT CHAR [32] ROS_GetSelCtrlModeStr()
    RETURN ROS_ControlModeToString(selected_control_mode)
ENDFCT

; Selects the cycle time associated with the specified integer
; Returns TRUE, if a valid integer was provided, otherwise FALSE
GLOBAL DEFFCT BOOL ROS_SelectCycleTime(cycle_time_int: IN)
    INT cycle_time_int

    selected_cycle_time = ROS_IntToCycleTime(cycle_time_int)
    IF selected_cycle_time == #NONE_CYCLE_TIME THEN
        RETURN FALSE
    ENDIF

    MsgNotify("Cycle time set to %1", "ProgramHandler",, ROS_CycleTimeToString(selected_cycle_time))
    RETURN TRUE
ENDFCT
