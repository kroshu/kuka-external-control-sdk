&ACCESS R
DEF program_handler()
    ; Software License Agreement (BSD License)
    ;
    ; Copyright (c) 2025, KUKA Hungaria Kft.
    ; All rights reserved.
    ;
    ; Redistribution and use in source and binary forms, with or without
    ; modification, are permitted provided that the following conditions are met:
    ;
    ;      * Redistributions of source code must retain the above copyright
    ;        notice, this list of conditions and the following disclaimer.
    ;      * Redistributions in binary form must reproduce the above copyright
    ;        notice, this list of conditions and the following disclaimer in the
    ;        documentation and/or other materials provided with the distribution.
    ;      * Neither the name of the copyright holder, nor the names of its
    ;        contributors may be used to endorse or promote products derived
    ;        from this software without specific prior written permission.
    ;
    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    ; POSSIBILITY OF SUCH DAMAGE.
END

GLOBAL DEFFCT BOOL ROS_StartProgram()
    CHAR program_name[64]
    CHAR s[256]
    INT k

    program_name[] = ROS_GetProgramName(selected_control_mode, selected_cycle_time)

    ; Check to see if a program is already selected - should not happen
    IF $PRO_STATE1 <> #P_FREE THEN
        ; If a program is already selected, log error and return
        ROS_Error1String("Program %1 is already selected", $PRO_NAME1[])
        RETURN FALSE
    ENDIF

    ; Select the new program
    s[] = "RUN/"
    k = strAdd(s[], program_name[])

    CWRITE($CMD, statement_state, command_mode, s[])
    IF NOT WaitForStateTransition(#P_FREE, 1000) THEN
        ROS_Error1String("Timeout selecting program %1", program_name[])
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

GLOBAL DEFFCT BOOL ROS_CancelProgram()
    ROS_Debug("Cancelling program...")

    ; Check to see if no program is selected
    IF $PRO_STATE1 == #P_FREE THEN
        RETURN TRUE
    ENDIF

    IF $PRO_STATE1 == #P_ACTIVE THEN
        ROS_Debug("Sending stop command")
        CWRITE($CMD, statement_state, command_mode, "STOP 1")
        IF NOT WaitForStateTransition(#P_ACTIVE, 1000) THEN
            ROS_Error("Timeout stopping program")
            RETURN FALSE
        ENDIF
    ENDIF

    ; Cancel the program
    ROS_Debug("Sending cancel command")
    CWRITE($CMD, statement_state, command_mode, "CANCEL 1")
    IF NOT WaitForState(#P_FREE, 1000) THEN
        ROS_Error("Timeout cancelling program")
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

GLOBAL DEFFCT BOOL ROS_ResetProgram()
    ; If program is already reset, just return
    IF $PRO_STATE1 == #P_RESET THEN
        RETURN TRUE
    ENDIF

    ; Check for no program selected
    IF $PRO_STATE1 == #P_FREE THEN
        ROS_Info("No program selected")
        RETURN FALSE
    ENDIF

    ; If the program is running, stop it
    IF $PRO_STATE1 == #P_ACTIVE THEN
        CWRITE($CMD,statement_state,command_mode, "STOP 1")
        IF NOT WaitForStateTransition(#P_ACTIVE, 1000) THEN
            ROS_Error("Timeout stopping program")
            RETURN FALSE
        ENDIF
    ENDIF

    ; Reset the program
    CWRITE($CMD,statement_state,command_mode, "RESET 1")
    IF NOT WaitForState(#P_RESET, 1000) THEN
        ROS_Error("Timeout resetting program")
        RETURN FALSE
    ENDIF

    RETURN TRUE
ENDFCT

DEFFCT BOOL WaitForState(ProState: IN, Timeout: IN)
    DECL PRO_STATE ProState
    INT Timeout
    INT StartTime, TriggerTime

    StartTime = $ROB_TIMER

    ; Set the trigger time based on the start time.  Account for integer rollover
    IF (INTEGER_MAX - Timeout) < StartTime THEN
        TriggerTime = Timeout - (INTEGER_MAX-StartTime)
    ELSE
        TriggerTime = StartTime + Timeout
    ENDIF

    IF TriggerTime >= StartTime THEN
        ; No worries about timer rollover
        REPEAT
            WAIT SEC 0.12
        UNTIL ($PRO_STATE1 == ProState) OR ($ROB_TIMER > TriggerTime) OR ($ROB_TIMER < StartTime)

    ELSE
        ; Timer rollover must be accounted for
        REPEAT
            WAIT SEC 0.12
        UNTIL ($PRO_STATE1 == ProState) OR (($ROB_TIMER > TriggerTime) AND ($ROB_TIMER < StartTime))
    ENDIF

    RETURN $PRO_STATE1 == ProState
ENDFCT

DEFFCT BOOL WaitForStateTransition(ProState: IN, Timeout: IN)
    DECL PRO_STATE ProState
    INT Timeout
    INT StartTime, TriggerTime

    StartTime = $ROB_TIMER

    ; Set the trigger time based on the start time.  Account for integer rollover
    IF ((INTEGER_MAX-Timeout) < StartTime) THEN
        TriggerTime = Timeout - (INTEGER_MAX-StartTime)
    ELSE
        TriggerTime = StartTime + Timeout
    ENDIF

    IF (TriggerTime >= StartTime) THEN
        ; No worries about timer rollover
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 <> ProState) OR ($ROB_TIMER > TriggerTime) OR ($ROB_TIMER < StartTime))
    ELSE
        ; Timer rollover must be accounted for
        REPEAT
            WAIT SEC 0.12
        UNTIL (($PRO_STATE1 <> ProState) OR (($ROB_TIMER > TriggerTime) AND ($ROB_TIMER < StartTime)))
    ENDIF

    IF ($PRO_STATE1 <> ProState) THEN
        RETURN TRUE
    ENDIF

    RETURN FALSE
ENDFCT

GLOBAL DEF ROS_SelectControlMode(mode: IN)
    DECL ControlMode mode

    ROS_Info1String("Control mode set to %1", ROS_ControlModeToString(mode))
    selected_control_mode = mode
END

; Returns the selected control mode as a string
GLOBAL DEFFCT CHAR [32] ROS_GetSelCtrlModeStr()
    RETURN ROS_ControlModeToString(selected_control_mode)
ENDFCT

GLOBAL DEFFCT ControlMode ROS_GetSelControlMode()
    RETURN selected_control_mode
ENDFCT

; Selects the cycle time associated with the specified integer
; Returns TRUE, if a valid integer was provided, otherwise FALSE
GLOBAL DEFFCT BOOL ROS_SelectCycleTime(cycle_time_int: IN)
    INT cycle_time_int

    selected_cycle_time = ROS_IntToCycleTime(cycle_time_int)
    IF selected_cycle_time == #NONE_CYCLE_TIME THEN
        RETURN FALSE
    ENDIF

    ROS_Debug1String("Cycle time set to %1", ROS_CycleTimeToString(selected_cycle_time))
    RETURN TRUE
ENDFCT

GLOBAL DEFFCT ROS_CycleTime ROS_GetSelCycTime()
    RETURN selected_cycle_time
ENDFCT

GLOBAL DEF ROS_ResetProgramHandler()
    selected_control_mode = #INACTIVE
    selected_cycle_time = #RSI_12MS
END
