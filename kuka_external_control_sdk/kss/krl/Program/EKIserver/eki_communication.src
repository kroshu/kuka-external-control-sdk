&ACCESS R
DEF eki_communication()
    ; Software License Agreement (BSD License)
    ;
    ; Copyright (c) 2022, KUKA Hungaria Kft.
    ; All rights reserved.
    ;
    ; Redistribution and use in source and binary forms, with or without
    ; modification, are permitted provided that the following conditions are met:
    ;
    ;      * Redistributions of source code must retain the above copyright
    ;        notice, this list of conditions and the following disclaimer.
    ;      * Redistributions in binary form must reproduce the above copyright
    ;        notice, this list of conditions and the following disclaimer in the
    ;        documentation and/or other materials provided with the distribution.
    ;      * Neither the name of the copyright holder, nor the names of its
    ;        contributors may be used to endorse or promote products derived
    ;        from this software without specific prior written permission.
    ;
    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    ; POSSIBILITY OF SUCH DAMAGE.
END

GLOBAL DEF EKI_ServerStart()
    DECL EKI_STATUS ret

    ; Init connection flag - will be set TRUE internally by EKI after connection is made
    $FLAG[ROS_EKI_CONN_FLAG] = FALSE
    ; Init data recv flag - will be set TRUE internally by EKI after data is received
    $FLAG[ROS_EKI_RECV_FLAG] = FALSE

    ret = EKI_Init(INTERFACE_NAME[])
    ret = EKI_Open(INTERFACE_NAME[])
END

DEF EKI_ServerReset()
    DECL EKI_STATUS ret
    ROS_ResetCommandHandler()
    ROS_ResetProgramHandler()
    ret = EKI_Clear(INTERFACE_NAME[])
    EKI_ServerStart()
END

; Tries to read received elements from buffer.
GLOBAL DEF EKI_ReceiveData(command: OUT)
    DECL Command command
    DECL EKI_STATUS ret

    ; Init cmd
    command.cmd_str[] = "None"
    command.control_mode = -1
    command.cycle_time = -1

    ; Verify a valid connection
    IF NOT IsClientConnected() THEN
        WAIT SEC 0.012
        RETURN
    ENDIF

    ; Skip processing if no data received.
    IF NOT DidReceiveData() THEN
        WAIT SEC 0.012
        RETURN
    ENDIF

    ; Reset flag immediately after msg notification
    $FLAG[ROS_EKI_RECV_FLAG] = FALSE

    ret = EKI_CheckBuffer(INTERFACE_NAME[], "External/@REQTYPE")

    IF ret.buff > 0 THEN
        ret = EKI_GetString(INTERFACE_NAME[], "External/@REQTYPE", command.cmd_str[])
        ret = EKI_GetInt(INTERFACE_NAME[], "External/@ControlMode", command.control_mode)
        ret = EKI_GetInt(INTERFACE_NAME[], "External/@CycleTime", command.cycle_time)
    ELSE
        ROS_Error("No valid data received")
        WAIT SEC 0.012
    ENDIF
END

GLOBAL DEF ROS_HandleConnection()
    IF IsClientConnected() <> connection_flag THEN
        connection_flag = IsClientConnected()
        IF IsClientConnected() THEN
            ROS_Info("External client connected")
        ELSE
            ROS_Info("External client disconnected")
            EKI_ServerReset()
        ENDIF
    ENDIF
END

GLOBAL DEF ROS_PublishEvent()
    DECL EKI_STATUS ret
    BOOL bool_ret
    INT event_int
    CHAR event_msg[64]
    CHAR x_path_send[32]

    ; Before publishing a response to a command, select the relevant part of the XML
    x_path_send[] = "Robot/Common"

    IF GetLastEvent() <> #NONE THEN
        IF NOT IsClientConnected() THEN
            ROS_Error("External client is not connected when trying to send event")
            RETURN
        ENDIF

        event_int = GetEventId()

        ; Only list commands that need special handling
        SWITCH last_event
            CASE #CONNECTED
                WriteInitDataToChannel()
                x_path_send[] = "Robot"
            CASE #SWITCH_OK
                event_msg[] = ROS_GetSelCtrlModeStr()
                ret = EKI_SetString(INTERFACE_NAME[], "Robot/Common/Event/@Message", event_msg[])
            CASE #STATUS_REQUESTED
                WriteStatusToChannel()
                x_path_send[] = "Robot/Status"
        ENDSWITCH

        ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Common/Event/@EventID", event_int)
        ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Common/Status/@Mode", 1)

        ; Transmit the current Run Mode
        ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Common/Status/@ControlMode", 1)

        ; Send the message
        ret = EKI_Send(INTERFACE_NAME[], x_path_send[])

        ; Reset event
        SetLastEvent(#NONE)
        bool_ret = StrClear(event_msg[])
        ret = EKI_SetString(INTERFACE_NAME[], "Robot/Common/Event/@Message", event_msg[])
    ENDIF
END

GLOBAL DEF SetLastEvent(event: IN)
    DECL EventType event
    last_event = event
END

GLOBAL DEFFCT EventType GetLastEvent()
    RETURN last_event
ENDFCT

GLOBAL DEFFCT BOOL IsClientConnected()
    RETURN $FLAG[ROS_EKI_CONN_FLAG]
ENDFCT

DEFFCT BOOL DidReceiveData()
    RETURN $FLAG[ROS_EKI_RECV_FLAG]
ENDFCT

DEF WriteStatusToChannel()
    DECL EKI_STATUS ret
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@ControlMode", ROS_GetSelCtrlModeInt())
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@CycleTime", ROS_GetSelCycTimeInt())
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@DrivesEnabled", ROS_BoolToInt($SR_DRIVES_ENABLE))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@DrivesPowered", ROS_BoolToInt($PERI_RDY))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@EmergencyStop", ROS_BoolToInt(NOT $ALARM_STOP OR NOT $ALARM_STOP_INTERN))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@GuardStop", ROS_BoolToInt(NOT $USER_SAF))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@InMotion", ROS_BoolToInt($PRO_MOVE))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@MotionPossible", ROS_BoolToInt($COULD_START_MOTION AND $PRO_ACT))
    ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Status/@OperationMode", ROS_OperationModeToInt())
END

DEF WriteInitDataToChannel()
    DECL EKI_STATUS eki_ret
    INT counter

    WriteStatusToChannel()

    ; Set general parameters
    eki_ret = EKI_SetString(INTERFACE_NAME[], "Robot/Init/@VER", INTERFACE_VERSION[])
    eki_ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Init/@IPOC", $ROB_TIMER)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Init/@NumAxes", $NUM_AX)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], "Robot/Init/@NumExternalAxes", $EX_AX_NUM)
    eki_ret = EKI_SetString(INTERFACE_NAME[], "Robot/Init/@Model", $ROBTRAFO[])
    eki_ret = EKI_SetString(INTERFACE_NAME[], "Robot/Init/@RobVer", $V_R1MADA[])

    ; Set axis-specific parameters for robot axes
    FOR counter = 1 TO $NUM_AX
        WriteAxisParamsToChannel("Robot/Init/Axis/A", counter, 0)
    ENDFOR

    ; Set axis-specific parameters for external axes (indexed from 7 to 12)
    FOR counter = 1 TO $EX_AX_NUM
        WriteAxisParamsToChannel("Robot/Init/Axis/E", counter, 6)
    ENDFOR
END

DEF WriteAxisParamsToChannel(base_path[]: IN, idx: IN, offset: IN)
    CHAR base_path[]
    INT idx
    INT offset
    DECL EKI_STATUS eki_ret
    DECL STATE_T state_ret
    BOOL bool_ret
    INT actual_idx
    INT swrite_offset
    CHAR x_path[64]
    CHAR axis_type_string[16]

    actual_idx = idx + offset

    bool_ret = StrCopy(axis_type_string[], AXIS_TYPE_MAP[$AXIS_TYPE[actual_idx],])
    swrite_offset = 0
    SWRITE(x_path[], state_ret, swrite_offset, "%s%d/@Type", base_path[], idx)
    eki_ret = EKI_SetString(INTERFACE_NAME[], x_path[], axis_type_string[])

    bool_ret = StrClear(x_path[])
    swrite_offset = 0
    SWRITE(x_path[], state_ret, swrite_offset, "%s%d/@RatioNum", base_path[], idx)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], x_path[], $RAT_MOT_AX[actual_idx].N)

    bool_ret = StrClear(x_path[])
    swrite_offset = 0
    SWRITE(x_path[], state_ret, swrite_offset, "%s%d/@RatioDen", base_path[], idx)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], x_path[], $RAT_MOT_AX[actual_idx].D)

    bool_ret = StrClear(x_path[])
    swrite_offset = 0
    SWRITE(x_path[], state_ret, swrite_offset, "%s%d/@MaxRPM", base_path[], idx)
    eki_ret = EKI_SetInt(INTERFACE_NAME[], x_path[], $VEL_AXIS_MA[actual_idx])
END

DEFFCT INT GetEventId()
    INT idx

    FOR idx = 1 TO EVENT_COUNT
        IF last_event == EVENT_TYPE_TUPLES[idx].event_type THEN
            RETURN EVENT_TYPE_TUPLES[idx].event_type_int
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN -1
ENDFCT
