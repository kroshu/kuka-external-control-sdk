&ACCESS RVP
&PARAM DISKPATH = KRC:\R1\Program\ROS
&PARAM EDITMASK = *
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
DEF command_handler()
    ; Software License Agreement (BSD License)
    ;
    ; Copyright (c) 2022, Kuka Robotics Corp
    ; All rights reserved.
    ;
    ; Redistribution and use in source and binary forms, with or without
    ; modification, are permitted provided that the following conditions are met:
    ;
    ;      * Redistributions of source code must retain the above copyright
    ;        notice, this list of conditions and the following disclaimer.
    ;      * Redistributions in binary form must reproduce the above copyright
    ;        notice, this list of conditions and the following disclaimer in the
    ;        documentation and/or other materials provided with the distribution.
    ;      * Neither the name of the copyright holder, nor the names of its
    ;        contributors may be used to endorse or promote products derived
    ;        from this software without specific prior written permission.
    ;
    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    ; POSSIBILITY OF SUCH DAMAGE.
END

GLOBAL DEF HandleCommand(cmd: IN)
    DECL Command cmd
    DECL CMDType cmd_enum
    DECL BOOL cmd_success
    DECL ControlMode ctrl_mode

    cmd_enum = ParseCommand(cmd.cmd_str[])

    IF (cmd_enum == #CMD_NONE) THEN
        ; If nothing was received, just RETURN
        RETURN
    ENDIF

    IF IsCommandValid(cmd_enum) THEN
        SWITCH cmd_enum
            CASE #CMD_INVALID
                SetLastEvent(#INVALID)
            CASE #CMD_CON
                SetLastEvent(#CONNECTED)
            CASE #CMD_START
                cmd_success = StartProgram(GetProgName(GetControlMode()))
                IF (cmd_success) THEN
                    current_driver_state = #Active
                    SetLastEvent(#STARTED)
                ELSE
                    SetLastEvent(#ERROR)
                ENDIF
            CASE #CMD_CANCEL
                cmd_success = CancelProgram()
                IF cmd_success THEN
                    current_driver_state = #Initialized
                    SetControlMode(#INACTIVE)
                    SetLastEvent(#CANCELLED)
                ELSE
                    SetLastEvent(#ERROR)
                ENDIF
            CASE #CMD_RESET
                cmd_success = ResetProgram()
                IF cmd_success THEN
                    current_driver_state = #INACTIVE
                    SetLastEvent(#RESET_OK)
                ELSE
                    SetLastEvent(#ERROR)
                ENDIF
            CASE #CMD_CHANGE
                SWITCH cmd.control_mode
                    CASE 1
                        ctrl_mode = #JOINT_POSITION
                    CASE 5
                        ctrl_mode = #CART_POSITION
                    DEFAULT
                        SetLastEvent(#ERROR)
                        RETURN
                ENDSWITCH
                SetControlMode(ctrl_mode)
                current_driver_state = #INACTIVE
                SetLastEvent(#SWITCH_OK)
            CASE #CMD_DRIVES_ON
                $DRIVES_ENABLE = TRUE
                SetLastEvent(#DRIVES_TURNED_ON)
            CASE #CMD_DRIVES_OFF
                $DRIVES_ENABLE = FALSE
                SetLastEvent(#DRIVES_TURNED_OFF)
        ENDSWITCH
    ELSE
        SetLastEvent(#INVALID)
        MsgNotify("Invalid transition requested")
    ENDIF
END

DEFFCT CMDType ParseCommand(cmd[]: IN)
    CHAR cmd[]
    DECL StringCommandPair pair
    INT idx

    FOR idx = 1 TO CMD_COUNT
        pair = STRING_COMMAND_PAIRS[idx]
        IF (StrComp(cmd[], pair.cmd_string[], #NOT_CASE_SENS)) THEN
            RETURN pair.cmd_type
        ENDIF
    ENDFOR

    RETURN #CMD_INVALID
ENDFCT

DEFFCT BOOL IsCommandValid(cmd: IN)
    DECL CMDType cmd
    CHAR cmd_string[32]
    CHAR state_string[32]
    INT valid_command_count

    ; Info message
    cmd_string[] = CommandToString(cmd)
    state_string[] = DriverStateToString(current_driver_state)
    MsgNotifyTextPar("Got command %1 while in state %2", "CommandHandler", 0, cmd_string[], state_string[])

    ; Actual check
    valid_command_count = GetValidCommandCount()
    SWITCH current_driver_state
        CASE #INITIALIZED
            RETURN IsCommandInArray(cmd, INIT_VALID_COMMANDS[], valid_command_count)
        CASE #INACTIVE
            RETURN IsCommandInArray(cmd, INACTIVE_VALID_COMMANDS[], valid_command_count)
        CASE #ACTIVE
            RETURN IsCommandInArray(cmd, ACTIVE_VALID_COMMANDS[], valid_command_count)
    ENDSWITCH
ENDFCT

GLOBAL DEF SetCurrentDriverState(state: IN)
    DECL DriverState state
    current_driver_state = state
END

; Maps the command enum to its string representation
DEFFCT CHAR [32] CommandToString(command: IN)
    DECL CMDType command
    DECL StringCommandPair pair
    INT idx

    FOR idx = 1 TO CMD_COUNT
        pair = STRING_COMMAND_PAIRS[idx]
        IF (command == pair.cmd_type) THEN
            RETURN pair.cmd_string[]
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "INVALID"
ENDFCT

; Maps the driver state to its string representation
DEFFCT CHAR [32] DriverStateToString(driver_state: IN)
    DECL DriverState driver_state
    INT idx

    FOR idx = 1 TO STATE_COUNT
        IF driver_state == STRING_STATE_PAIRS[idx].state THEN
            RETURN STRING_STATE_PAIRS[idx].state_string
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN "INVALID"
ENDFCT

; Returns the number of valid command enum values in the currently active driver state
DEFFCT INT GetValidCommandCount()
    INT idx

    FOR idx = 1 TO STATE_COUNT
        IF current_driver_state == STATE_VALID_COUNTS[idx].state THEN
            RETURN STATE_VALID_COUNTS[idx].valid_count
        ENDIF
    ENDFOR

    ; Unreachable
    RETURN -1
ENDFCT

; Checks if the specified command enum is present in the provided array
DEFFCT BOOL IsCommandInArray(cmd: IN, array[]: IN, size: IN)
    DECL CMDType cmd
    DECL CMDType array[]
    INT size
    INT idx

    FOR idx = 1 TO size
        IF array[idx] == cmd THEN
            RETURN TRUE
        ENDIF
    ENDFOR

    RETURN FALSE
ENDFCT
